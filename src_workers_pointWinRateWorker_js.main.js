/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/badmintonMatchSimulator.js":
/*!****************************************!*\
  !*** ./src/badmintonMatchSimulator.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ BadmintonMatchSimulator)\n/* harmony export */ });\n/* harmony import */ var _singlesGame__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./singlesGame */ \"./src/singlesGame.js\");\n/* harmony import */ var _singlesMatch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./singlesMatch */ \"./src/singlesMatch.js\");\n\n\n\nclass BadmintonMatchSimulator {\n    \n    static simulateMatchesOffGameWinRate(n = 1, p1GameWinRate = 0.5, numGamesToWin = 2) {\n        const results = [];\n        for (let i = 0; i < n; i++) {\n            results.push(this.simulateMatchOffGameWinRate(p1GameWinRate, numGamesToWin));\n        }\n        return results;\n    }\n\n    static simulateMatchOffGameWinRate(p1GameWinRate = 0.5, numGamesToWin = 2) {\n        const match = new _singlesMatch__WEBPACK_IMPORTED_MODULE_1__[\"default\"](numGamesToWin);\n\n        while (!match.isOver()) {\n            match.addGame(this.simulateGameOffGameWinRate(p1GameWinRate));\n        }\n\n        return match;\n    }\n\n    static simulateGameOffGameWinRate(p1GameWinRate = 0.5, maxPoints = 30) {\n        return Math.random() <= p1GameWinRate ? new _singlesGame__WEBPACK_IMPORTED_MODULE_0__[\"default\"](21, 0, maxPoints) : new _singlesGame__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0, 21, maxPoints);\n    }\n\n    static simulateSinglesMatches(n = 1, p1PointWinRate = 0.5, startingP1Score = 0, startingP2Score = 0, numGamesToWin = 2, \n                            gamePoint = 21, gamePointCap = 30, rallyScoring = true, server = 'RANDOM', winBy = 2) {\n        const results = [];\n        for (let i = 0; i < n; i++) {\n            results.push(this.simulateSinglesMatch(p1PointWinRate, startingP1Score, startingP2Score, numGamesToWin,\n                                                gamePoint, gamePointCap, rallyScoring, server, winBy));\n        }\n        return results;\n    }\n\n    /**\n     * Returns a list of games\n     * @param {float} p1PointWinRate - between 0 and 1 inclusive\n     */\n    static simulateSinglesMatch(p1PointWinRate = 0.5, startingP1Score = 0, startingP2Score = 0, numGamesToWin = 2,\n                            gamePoint = 21, gamePointCap = 30, rallyScoring = true, server = 'RANDOM', winBy = 2) {\n        const match = new _singlesMatch__WEBPACK_IMPORTED_MODULE_1__[\"default\"](numGamesToWin);\n\n        while (!match.isOver()) {\n            const game = this.simulateSinglesGame(p1PointWinRate, startingP1Score, startingP2Score, \n                                                gamePoint, gamePointCap, rallyScoring, server, winBy);\n            match.addGame(game);\n            server = game.didP1Win() ? 'P1' : 'P2';\n        }\n\n        return match;\n    }\n    \n    /**\n     * Returns a game\n     * @param {float} p1PointWinRate - between 0 and 1 inclusive\n     */\n    static simulateSinglesGame(p1PointWinRate = 0.5, startingP1Score = 0, startingP2Score = 0, gamePoint = 21, \n                            gamePointCap = 30, rallyScoring = true, server = 'RANDOM', winBy = 2) {\n        const game = new _singlesGame__WEBPACK_IMPORTED_MODULE_0__[\"default\"](startingP1Score, startingP2Score, gamePoint, gamePointCap, rallyScoring, server, winBy);\n        while (!game.isOver()) {\n            const rand = Math.random();\n            if (rand <= p1PointWinRate) {\n                game.addP1Point();\n            } else {\n                game.addP2Point();\n            }\n        }\n        return game;\n    }\n\n    static simulateSinglesMatchesWithServes(n = 1, p1ServeWinRate = 0.5, p2ServeWinRate = 0.5, startingP1Score = 0, \n                                startingP2Score = 0, numGamesToWin = 2, gamePointCap = 30, server = 'RANDOM') {\n        const results = [];\n        for (let i = 0; i < n; i++) {\n            results.push(this.simulateSinglesMatchWithServes(p1ServeWinRate, p2ServeWinRate, startingP1Score, startingP2Score, numGamesToWin, gamePointCap, server));\n        }\n        return results;\n    }\n\n    /**\n     * Returns a list of games\n     * @param {float} p1PointWinRate - between 0 and 1 inclusive\n     */\n    static simulateSinglesMatchWithServes(p1ServeWinRate = 0.5, p2ServeWinRate = 0.5, startingP1Score = 0, \n                                    startingP2Score = 0, numGamesToWin = 2, gamePointCap = 30, server = 'RANDOM') {\n        const match = new _singlesMatch__WEBPACK_IMPORTED_MODULE_1__[\"default\"](numGamesToWin);\n\n        while (!match.isOver()) {\n            match.addGame(this.simulateSinglesGameWithServes(p1ServeWinRate, p2ServeWinRate, startingP1Score, startingP2Score, gamePointCap, server));\n        }\n\n        return match;\n    }\n\n    /**\n     * Assumes that p1 serves first\n     * @param {*} p1ServeWinRate \n     * @param {*} p2ServeWinRate \n     */\n    static simulateSinglesGameWithServes(p1ServeWinRate = 0.5, p2ServeWinRate = 0.5, startingP1Score = 0, \n                                    startingP2Score = 0, maxPoints = 30, gamePointCap = 30, server = 'RANDOM') {\n        const game = new _singlesGame__WEBPACK_IMPORTED_MODULE_0__[\"default\"](startingP1Score, startingP2Score, maxPoints, gamePointCap, server);\n        while (!game.isOver()) {\n            const rand = Math.random();\n            const rate = game.isP1Serving() ? p1ServeWinRate : 1 - p2ServeWinRate;\n            if (rand <= rate) {\n                game.addP1Point();\n            } else {\n                game.addP2Point();\n            }\n        }\n        return game;\n    }\n\n    static simulateDoublesGameWithServes(p1ServeWinRate, p2ServeWinRate, p3ServeWinRate, p4ServeWinRate, startingTeam1Score=0, startingTeam2Score=0) {\n        \n    }\n}\n\n\n\n//# sourceURL=webpack://badminton_match_simulator/./src/badmintonMatchSimulator.js?");

/***/ }),

/***/ "./src/singlesGame.js":
/*!****************************!*\
  !*** ./src/singlesGame.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SinglesGame)\n/* harmony export */ });\nclass SinglesGame {\n\n    constructor(p1Score = 0, p2Score = 0, gamePoint = 21, gamePointCap = 30, \n            rallyScoring = true, server = 'RANDOM', winBy = 2) {\n        // this.validate(p1Score, p2Score);\n        this.startingP1Score = Number(p1Score);\n        this.startingP2Score = Number(p2Score);\n        this.p1Score = Number(p1Score);\n        this.p2Score = Number(p2Score);\n        this.winBy = Number(winBy);\n\n        // number of points the game is normally played to\n        this.gamePoint = Number(gamePoint);\n\n        // maximum number of points a player can have.\n        this.gamePointCap = Number(gamePointCap);\n\n        this.setServer(server);\n        this.mostConsecutiveP1Points = 0;\n        this.mostConsecutiveP2Points = 0;\n        this.currentConsecutiveP1Points = 0;\n        this.currentConsecutiveP2Points = 0;\n        this.biggestP1Lead = Math.max(0, p1Score - p2Score);\n        this.biggestP2Lead = Math.max(0, p2Score - p1Score);\n        // -1 signifies that the player did not have any game point opportunities at all\n        this.numMissedP1GamePoints = this.isP1GamePoint() ? 0 : -1;\n        this.numMissedP2GamePoints = this.isP2GamePoint() ? 0 : -1;\n        this.rallyScoring = rallyScoring;\n        this.numRalliesWonP1 = 0;\n        this.numRalliesWonP2 = 0;\n    }\n\n    setServer(server) {\n        if (server === 'P1') {\n            this._isP1Serving = true;\n        } else if (server === 'P2') {\n            this._isP1Serving = false;\n        } else {\n            this._isP1Serving = Math.random() < 0.5;\n        }\n    }\n\n    validate(p1Score, p2Score) {\n        // TODO\n    }\n\n    isGamePoint() {\n        return this.isP1GamePoint() || this.isP2GamePoint();\n    }\n\n    isP1GamePoint() {\n        return (!this.rallyScoring && this._isP1Serving || this.rallyScoring) && \n            this.p1Score === this.gamePointCap - 1 || this.p1Score > this.p2Score && this.p1Score >= this.gamePoint - 1;\n    }\n\n    isP2GamePoint() {\n        return (!this.rallyScoring && !this._isP1Serving || this.rallyScoring) && \n            this.p2Score === this.gamePointCap - 1 || this.p2Score > this.p1Score && this.p2Score >= this.gamePoint - 1;\n    }\n\n    isOver() {\n        return (this.p1Score >= this.gamePointCap || this.p1Score >= this.gamePoint && this.p2Score <= this.p1Score - this.winBy)\n        || (this.p2Score >= this.gamePointCap || this.p2Score >= this.gamePoint && this.p1Score <= this.p2Score - this.winBy);\n    }\n\n    didP1Win() {\n        return this.isOver() && this.p1Score > this.p2Score;\n    }\n\n    didP2Win() {\n        return this.isOver() && this.p2Score > this.p1Score;\n    }\n\n    addP1Point() {\n        if (this.isOver()) return;\n\n        this.numRalliesWonP1++;\n        if (this.isP2GamePoint()) {\n            this.numMissedP2GamePoints = Math.max(this.numMissedP2GamePoints + 1, 1);\n        }\n\n        if (!this.rallyScoring && !this._isP1Serving) {\n            this._isP1Serving = true;\n            return;\n        }\n\n        if (this.isP1Serving()) {\n            this.currentConsecutiveP1Points++;\n        } else {\n            this.currentConsecutiveP1Points = 1;\n        }\n\n        this.mostConsecutiveP1Points = Math.max(this.mostConsecutiveP1Points, this.currentConsecutiveP1Points);\n        this._isP1Serving = true;\n        this.p1Score++;\n        this.biggestP1Lead = Math.max(this.biggestP1Lead, this.p1Score - this.p2Score);\n        if (this.isP1GamePoint()) {\n            this.numMissedP1GamePoints = Math.max(0, this.numMissedP1GamePoints);\n        }\n    }\n\n    addP2Point() {\n        if (this.isOver()) return;\n\n        this.numRalliesWonP2++;\n        if (this.isP1GamePoint()) {\n            this.numMissedP1GamePoints = Math.max(this.numMissedP1GamePoints + 1, 1);\n        }\n\n        if (!this.rallyScoring && this._isP1Serving) {\n            this._isP1Serving = false;\n            return;\n        }\n\n        \n\n        if (this.isP2Serving()) {\n            this.currentConsecutiveP2Points++;\n        } else {\n            this.currentConsecutiveP2Points = 1;\n        }\n\n        this.mostConsecutiveP2Points = Math.max(this.mostConsecutiveP2Points, this.currentConsecutiveP2Points);\n        this._isP1Serving = false;\n        this.p2Score++;\n        this.biggestP2Lead = Math.max(this.biggestP2Lead, this.p2Score - this.p1Score);\n\n        if (this.isP2GamePoint()) {\n            this.numMissedP2GamePoints = Math.max(0, this.numMissedP2GamePoints);\n        }\n    }\n\n    getP1Score() {\n        return this.p1Score;\n    }\n\n    getP2Score() {\n        return this.p2Score;\n    }\n\n    getStartingP1Score() {\n        return this.startingP1Score;\n    }\n\n    getStartingP2Score() {\n        return this.startingP2Score;\n    }\n\n    isP1Serving() {\n        return this._isP1Serving;\n    }\n\n    isP2Serving() {\n        return !this.isP1Serving();\n    }\n\n    getBiggestP1Lead() {\n        return this.biggestP1Lead;\n    }\n\n    getBiggestP2Lead() {\n        return this.biggestP2Lead;\n    }\n\n    getNumMissedP1GamePoints() {\n        return this.numMissedP1GamePoints;\n    }\n\n    getNumMissedP2GamePoints() {\n        return this.numMissedP2GamePoints;\n    }\n\n    getGamePointCap() {\n        return this.gamePointCap;\n    }\n\n    getNumRalliesWonP1() {\n        return this.numRalliesWonP1;\n    }\n\n    getNumRalliesWonP2() {\n        return this.numRalliesWonP2;\n    }\n\n    getNumRalliesPlayed() {\n        return this.numRalliesWonP1 + this.numRalliesWonP2;\n    }\n\n    print() {\n        console.log(`${this.p1Score}-${this.p2Score}`);\n    }\n}\n\n\n\n//# sourceURL=webpack://badminton_match_simulator/./src/singlesGame.js?");

/***/ }),

/***/ "./src/singlesMatch.js":
/*!*****************************!*\
  !*** ./src/singlesMatch.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SinglesMatch)\n/* harmony export */ });\nclass SinglesMatch {\n\n    constructor(numGamesToWin = 2, games = []) {\n        this.p1Wins = 0;\n        this.p2Wins = 0;\n        this.games = [];\n        this.numMissedP1MatchPoints = 0;\n        this.numMissedP2MatchPoints = 0;\n        this.numGamesToWin = numGamesToWin;\n        this.gamePointCap = 0;\n\n        games.forEach((game) => {\n            this.addGame(game);\n        })\n    }\n\n    getGames() {\n        return this.games;\n    }\n\n    getNumGames() {\n        return this.games.length;\n    }\n\n    getNumGamesP1Won() {\n        return this.p1Wins;\n    }\n\n    getNumGamesP2Won() {\n        return this.p2Wins;\n    }\n\n    addGame(game) {\n        if (!this.isOver() && game && game.isOver()) {\n            if (game.didP1Win()) {\n                this.p1Wins++;\n            } else {\n                this.p2Wins++;\n            }\n            this.games.push(game);\n            this.gamePointCap = Math.max(this.gamePointCap, game.getGamePointCap());\n\n            const lastPossibleGameNumber = this.numGamesToWin * 2 - 1;\n            if (this.games.length == lastPossibleGameNumber) {\n                this.numMissedP1MatchPoints = game.getNumMissedP1GamePoints();\n                this.numMissedP2MatchPoints = game.getNumMissedP2GamePoints();\n            } else if (this.p1Wins == this.numGamesToWin) {\n                this.numMissedP1MatchPoints = game.getNumMissedP1GamePoints();\n            } else if (this.p2Wins == this.numGamesToWin) {\n                this.numMissedP2MatchPoints = game.getNumMissedP2GamePoints();\n            }\n        }\n    }\n\n    isOver() {\n        return this.didP1Win() || this.didP2Win();\n    }\n\n    didP1Win() {\n        return this.p1Wins >= this.numGamesToWin;\n    }\n\n    didP2Win() {\n        return this.p2Wins >= this.numGamesToWin;\n    }\n\n    getNumMissedP1MatchPoints() {\n        return this.numMissedP1MatchPoints;\n    }\n\n    getNumMissedP2MatchPoints() {\n        return this.numMissedP2MatchPoints;\n    }\n\n    getGamePointCap() {\n        return this.gamePointCap;\n    }\n\n    print() {\n        this.games.forEach((game) => {\n            game.print();\n        });\n    }\n}\n\n\n\n//# sourceURL=webpack://badminton_match_simulator/./src/singlesMatch.js?");

/***/ }),

/***/ "./src/singlesMatchesStats.js":
/*!************************************!*\
  !*** ./src/singlesMatchesStats.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SinglesMatchesStats)\n/* harmony export */ });\n/* harmony import */ var utility__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utility */ \"./src/utility.js\");\n\n\n/**\n * Calculates and stores stats for a set of singles matches.\n */\nclass SinglesMatchesStats {\n\n    constructor(singlesMatches=[]) {\n        this.matches = singlesMatches;\n        this.p1GameWins = 0;\n        this.p2GameWins = 0;\n        this.p1GameWins_p2Scores = [];\n        this.p2GameWins_p1Scores = [];\n        this.numMatchesTo2GamesP1Won = 0;\n        this.numMatchesTo2GamesP2Won = 0;\n        this.numMatchesTo3GamesP1Won = 0;\n        this.numMatchesTo3GamesP2Won = 0;\n        this.biggestP1Leads = [];\n        this.biggestP2Leads = [];\n        this.numMissedP1GamePoints = 0;\n        this.numMissedP2GamePoints = 0;\n        this.missedP1GamePoints = [];\n        this.missedP2GamePoints = [];\n        this.missedP1MatchPoints = [];\n        this.missedP2MatchPoints = [];\n        this.p1MatchWins = 0;\n        this.p2MatchWins = 0;\n        this.numRalliesWonP1 = 0;\n        this.numRalliesWonP2 = 0;\n        this.numPointsWonP1 = 0;\n        this.numPointsWonP2 = 0;\n        this.numMatches = singlesMatches.length;\n\n        this.calculateStats();\n    }\n\n    addMatches(singlesMatches) {\n        this.matches = singlesMatches;\n        this.numMatches += singlesMatches.length;\n        this.calculateStats();\n    }\n\n    calculateStats() {\n        this.matches.forEach((match) => {\n            if (match.didP1Win()) {\n                this.p1MatchWins++;\n                if (match.getNumGames() == 2) {\n                    this.numMatchesTo2GamesP1Won++;\n                } else if (match.getNumGames() == 3) {\n                    this.numMatchesTo3GamesP1Won++;\n                }\n            } else if (match.didP2Win()) {\n                this.p2MatchWins++;\n                if (match.getNumGames() == 2) {\n                    this.numMatchesTo2GamesP2Won++;\n                } else if (match.getNumGames() == 3) {\n                    this.numMatchesTo3GamesP2Won++;\n                }\n            }\n            \n            this.missedP1MatchPoints.push(match.getNumMissedP1MatchPoints());\n            this.missedP2MatchPoints.push(match.getNumMissedP2MatchPoints());\n\n            match.getGames().forEach((game) => {\n                this.numRalliesWonP1 += game.getNumRalliesWonP1();\n                this.numRalliesWonP2 += game.getNumRalliesWonP2();\n\n                this.numPointsWonP1 += game.getP1Score() - game.getStartingP1Score();\n                this.numPointsWonP2 += game.getP2Score() - game.getStartingP2Score();\n\n                this.numMissedP1GamePoints += game.getNumMissedP1GamePoints() > 0 ? game.getNumMissedP1GamePoints() : 0;\n                this.numMissedP2GamePoints += game.getNumMissedP2GamePoints() > 0 ? game.getNumMissedP2GamePoints() : 0;\n\n                if (game.didP1Win()) {\n                    this.p1GameWins++;\n                    (0,utility__WEBPACK_IMPORTED_MODULE_0__.increment)(this.p1GameWins_p2Scores, game.getP2Score());\n                } else if (game.didP2Win()) {\n                    this.p2GameWins++;\n                    (0,utility__WEBPACK_IMPORTED_MODULE_0__.increment)(this.p2GameWins_p1Scores, game.getP1Score());\n                }\n                (0,utility__WEBPACK_IMPORTED_MODULE_0__.increment)(this.biggestP1Leads, game.getBiggestP1Lead());\n                (0,utility__WEBPACK_IMPORTED_MODULE_0__.increment)(this.biggestP2Leads, game.getBiggestP2Lead());\n\n                (0,utility__WEBPACK_IMPORTED_MODULE_0__.increment)(this.missedP1GamePoints, game.getNumMissedP1GamePoints());\n                (0,utility__WEBPACK_IMPORTED_MODULE_0__.increment)(this.missedP2GamePoints, game.getNumMissedP2GamePoints());\n            });\n        });\n    }\n\n    getMatches() {\n        return this.matches;\n    }\n\n    getNumMatches() {\n        return this.numMatches;\n    }\n\n    getP1MatchWins() {\n        return this.p1MatchWins;\n    }\n\n    getP2MatchWins() {\n        return this.p2MatchWins;\n    }\n\n    getP1GameWins() {\n        return this.p1GameWins;\n    }\n\n    getP2GameWins() {\n        return this.p2GameWins;\n    }\n\n    getP1GameWinsWithP2Scores() {\n        return this.p1GameWins_p2Scores;\n    }\n\n    getP2GameWinsWithP1Scores() {\n        return this.p2GameWins_p1Scores;\n    }\n\n    getNumMatchesTo2Games() {\n        return this.numMatchesTo2GamesP1Won + this.numMatchesTo2GamesP2Won;\n    }\n\n    getNumMatchesTo2GamesP1Won() {\n        return this.numMatchesTo2GamesP1Won;\n    }\n\n    getNumMatchesTo2GamesP2Won() {\n        return this.numMatchesTo2GamesP2Won;\n    }\n\n    getNumMatchesTo3Games() {\n        return this.numMatchesTo3GamesP1Won + this.numMatchesTo3GamesP2Won;\n    }\n\n    getNumMatchesTo3GamesP1Won() {\n        return this.numMatchesTo3GamesP1Won;\n    }\n\n    getNumMatchesTo3GamesP2Won() {\n        return this.numMatchesTo3GamesP2Won;\n    }\n\n    getBiggestP1Leads() {\n        return this.biggestP1Leads;\n    }\n\n    getBiggestP2Leads() {\n        return this.biggestP2Leads;\n    }\n\n    getMissedP1GamePoints() {\n        return this.missedP1GamePoints;\n    }\n\n    getMissedP2GamePoints() {\n        return this.missedP2GamePoints;\n    }\n\n    getMissedP1MatchPoints() {\n        return this.missedP1MatchPoints;\n    }\n\n    getMissedP2MatchPoints() {\n        return this.missedP2MatchPoints;\n    }\n\n    getNumRalliesPlayed() {\n        return this.numRalliesWonP1 + this.numRalliesWonP2;\n    }\n\n    getNumRalliesWonP1() {\n        return this.numRalliesWonP1;\n    }\n\n    getNumRalliesWonP2() {\n        return this.numRalliesWonP12;\n    }\n\n    getNumPointsPlayed() {\n        return this.numPointsWonP1 + this.numPointsWonP2;\n    }\n\n    getNumPointsWonP1() {\n        return this.numPointsWonP1;\n    }\n\n    getNumPointsWonP2() {\n        return this.numPointsWonP2;\n    }\n\n    getNumMissedGamePoints() {\n        return this.numMissedP1GamePoints + this.numMissedP2GamePoints;\n    }\n\n    toObject() {\n        // TODO, if ever needed...\n        return {\n            p1MatchWins: this.getP1MatchWins(),\n            p2MatchWins: this.getP2MatchWins(),\n            numMatchesTo2Games: this.getNumMatchesTo2Games(),\n            numMatchesTo3Games: this.getNumMatchesTo3Games(),\n            numMatchesTo2GamesP1Won: this.getNumMatchesTo2GamesP1Won(),\n            numMatchesTo3GamesP1Won: this.getNumMatchesTo3GamesP1Won(),\n            numMatchesTo2GamesP2Won: this.getNumMatchesTo2GamesP2Won(),\n            numMatchesTo3GamesP2Won: this.getNumMatchesTo3GamesP2Won(),\n            numRalliesWonP1: this.getNumRalliesWonP1(),\n            numRalliesWonP2: this.getNumRalliesWonP2(),\n            numRalliesPlayed: this.getNumRalliesPlayed(),\n            numPointsWonP1: this.getNumPointsWonP1(),\n            numPointsWonP2: this.getNumPointsWonP2(),\n            numPointsPlayed: this.getNumPointsPlayed(),\n            numMatches: this.getNumMatches()\n        };\n    }\n}\n\n//# sourceURL=webpack://badminton_match_simulator/./src/singlesMatchesStats.js?");

/***/ }),

/***/ "./src/utility.js":
/*!************************!*\
  !*** ./src/utility.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"create3ColumnTable\": () => (/* binding */ create3ColumnTable),\n/* harmony export */   \"create3x10Table\": () => (/* binding */ create3x10Table),\n/* harmony export */   \"getDataProbabilities\": () => (/* binding */ getDataProbabilities),\n/* harmony export */   \"increment\": () => (/* binding */ increment),\n/* harmony export */   \"removeAllTables\": () => (/* binding */ removeAllTables),\n/* harmony export */   \"truncateZeroes\": () => (/* binding */ truncateZeroes)\n/* harmony export */ });\n/**\n * Given an array of data, return an array of the same length but with the\n * probability of the occurrence of each instead of the frequency.\n * \n * Example: [1, 2, 0, 2] -> [.2, .4, 0, .4]\n * @param {*} data - an array of number values\n */\nfunction getDataProbabilities(data) {\n    if (!data || data.length === 0) {\n        return [];\n    }\n    const sum = data.reduce((a,b) => a + b);\n    const probabilities = [];\n    data.forEach((value) => {\n        if (sum == 0) {\n            probabilities.push(0);\n        } else {\n            probabilities.push(value / sum * 100);\n        }\n    });\n    return probabilities;\n}\n\nfunction increment(arr, index) {\n    if (!arr || index < 0) return;\n    while (index >= arr.length) {\n        arr.push(0);\n    }\n    arr[index]++;\n}\n\n/**\n * Removes all 0s from the end of the array\n * Example: [3, 2, 3, 0, 0] -> [3, 2, 3]\n * @param {*} arr - an array of numbers\n */\nfunction truncateZeroes(arr) {\n    if (!arr || arr.length === 0) return arr;\n\n    let i = arr.length - 1;\n    while (arr[i] === 0) {\n        i--;\n    }\n    const lastZeroIndex = i + 1;\n    arr.splice(lastZeroIndex, Infinity);\n    return arr;\n}\n\nfunction removeAllTables() {\n    const tables = document.querySelectorAll('table');\n    tables.forEach((table) => {\n        table.parentNode.removeChild(table);\n    });\n}\n\nfunction create3x10Table(data, parentId, headers=['Points', 'Percentage', 'Points', 'Percentage', 'Points', 'Percentage']) {\n    if (!data) {\n        return;\n    }\n\n    const tbl = document.createElement('table');\n    const tbdy = document.createElement('tbody');\n\n    // Create headers row\n    let tr = document.createElement('tr');\n    headers.forEach((header) => {\n        const th = document.createElement('th');\n        const headerTextNode = document.createTextNode(header);\n        th.appendChild(headerTextNode);\n        tr.appendChild(th);\n    });\n    tbdy.appendChild(tr);\n\n    // Create rest of the table\n    for (let row = 0; row < 10; row++) {\n        tr = document.createElement('tr');\n        for (let col = 0; col < 6; col++) {\n            const td = document.createElement('td');\n            const index = col % 2 == 0 ? row + 5 * col : row + 10 * Math.floor(col / 2);\n\n            if (data[index] == null || data[index] == undefined) break;\n            const value = col % 2 == 0 ? index : data[index].toFixed(3) + \"%\";\n            td.appendChild(document.createTextNode(value));\n            tr.appendChild(td);\n        }\n        tbdy.appendChild(tr);\n    }\n    \n    tbl.append(tbdy);\n    const parent = document.getElementById(parentId);\n    if (parent) {\n        parent.appendChild(tbl);\n    }\n}\n\nfunction create3ColumnTable(data, parentId, precision=3, headers=['Points', 'Percentage', 'Points', 'Percentage', 'Points', 'Percentage']) {\n    if (!data) {\n        return;\n    }\n\n    const tbl = document.createElement('table');\n    const tbdy = document.createElement('tbody');\n\n    // Create headers row\n    let tr = document.createElement('tr');\n    headers.forEach((header) => {\n        const th = document.createElement('th');\n        const headerTextNode = document.createTextNode(header);\n        th.appendChild(headerTextNode);\n        tr.appendChild(th);\n    });\n    tbdy.appendChild(tr);\n\n    const numRows = Math.ceil(data.length / 3);\n    // Create rest of the table\n    for (let row = 0; row < numRows; row++) {\n        tr = document.createElement('tr');\n        for (let col = 0; col < 6; col++) {\n            const td = document.createElement('td');\n            const index = col % 2 == 0 ? row + numRows * (col / 2) : row + numRows * Math.floor(col / 2);\n\n            if (data[index] == null || data[index] == undefined) break;\n\n            const value = col % 2 == 0 ? index : data[index].toFixed(precision) + \"%\";\n            td.appendChild(document.createTextNode(value));\n            tr.appendChild(td);\n        }\n        tbdy.appendChild(tr);\n    }\n    \n    tbl.append(tbdy);\n    const parent = document.getElementById(parentId);\n    if (parent) {\n        parent.appendChild(tbl);\n    }\n}\n\n//# sourceURL=webpack://badminton_match_simulator/./src/utility.js?");

/***/ }),

/***/ "./src/workers/pointWinRateWorker.js":
/*!*******************************************!*\
  !*** ./src/workers/pointWinRateWorker.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var badmintonMatchSimulator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! badmintonMatchSimulator */ \"./src/badmintonMatchSimulator.js\");\n/* harmony import */ var singlesMatchesStats__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! singlesMatchesStats */ \"./src/singlesMatchesStats.js\");\n\n\n\nconst MAX_BATCH_MATCHES_SIZE = 100000;\n\nonmessage = function(e) {\n    try {\n        simulate(e);\n    } catch(exception) {\n        console.log('Exception occurred in pointWinRateWorker: ' + exception);\n        postMessage({});\n    }\n}\n\nfunction simulate(e) {\n    const data = e.data;\n    if (!data || data.type === 'webpackOk') {\n        // we get onmessage events from webpack when the page first loads\n        return;\n    }\n\n    const numMatches = data.numMatches;\n    const numGamesToWin = data.numGamesToWin;\n    const gamePoint = data.gamePoint;\n    const gamePointCap = data.gamePointCap;\n    const p1WinRate = data.p1WinRate;\n    const p1StartingScore = data.p1StartingScore;\n    const p2StartingScore = data.p2StartingScore;\n    const rallyScoring = data.rallyScoring;\n    const server = data.server;\n    const winBy = data.winBy;\n\n    let remainingNumMatches = data.numMatches;\n    const stats = new singlesMatchesStats__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n\n    while (remainingNumMatches > 0) {\n        let batchSize = Math.min(remainingNumMatches, MAX_BATCH_MATCHES_SIZE);\n        const matches = badmintonMatchSimulator__WEBPACK_IMPORTED_MODULE_0__[\"default\"].simulateSinglesMatches(batchSize, p1WinRate, p1StartingScore, \n            p2StartingScore, numGamesToWin, gamePoint, gamePointCap, rallyScoring, server, winBy);\n        stats.addMatches(matches);\n        remainingNumMatches -= batchSize;\n    }\n\n    // Only need to assign values for fields that do not have the same name as what's in singlesMatchesStats.js\n    const result = Object.assign(stats, {\n        numMatchesTo2Games: stats.getNumMatchesTo2Games(),\n        numMatchesTo3Games: stats.getNumMatchesTo3Games(),\n        numRalliesPlayed: stats.getNumRalliesPlayed(),\n        numPointsPlayed: stats.getNumPointsPlayed(),\n        numMissedGamePoints: stats.getNumMissedGamePoints(),\n    });\n\n    // passing back a SinglesMatchesStats object will only provide back the fields of the stats\n    // object and it won't have all the methods available. We have to provide back the desired\n    // attributes in a JavaScript object instead.\n    postMessage({result});\n}\n\n//# sourceURL=webpack://badminton_match_simulator/./src/workers/pointWinRateWorker.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/workers/pointWinRateWorker.js");
/******/ 	
/******/ })()
;